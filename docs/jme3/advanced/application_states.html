<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Application States :: jMonkeyEngine Docs</title>
    <link rel="canonical" href="https://mitm001.github.io/jme-wiki/docs/jme3/advanced/application_states.html">
    <meta name="generator" content="Antora 2.3.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
<meta property="og:image" content="https://wiki.jmonkeyengine.org/_/img/iconx128.png">
<meta property="og:description" content="Application States">
<meta property="og:title" content="jMonkeyEngine Docs">
<link rel="stylesheet" href="../../../_/css/site-extra.css">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://mitm001.github.io/jme-wiki">
        <img alt="" src="../../../_/img/jme-logo.png" height="32" type="image/x-icon">
      </a>
      <div class="navbar-item hide-for-print">
        <input id="search-input" type="text" placeholder="Search docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item theme-switch-wrapper">
          <label class="theme-switch" for="checkbox">
            <input type="checkbox" id="checkbox" />
            <div class="slider round"></div>
          </label>
        </div>
        <a class="navbar-item" href="https://github.com/jmonkeyengine/wiki">Github</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../documentation.html">Docs</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../documentation.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="https://javadoc.jmonkeyengine.org/v3.3.2-stable">JavaDoc</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../jme3.html">jMonkeyEngine 3</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Intermediate Tutorials</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Concepts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/best_practices.html">Best Practices</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/simpleapplication.html">Simple Application</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../features.html">Features</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/optimization.html">Optimization</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../faq.html">FAQ</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Math Concepts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../math_for_dummies.html">Math For Dummies</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/math.html">Math</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../math.html">More Math</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../rotate.html">Rotate</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../math_video_tutorials.html">Math Video Tutorials</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">3D Graphics Concepts</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/multi-media_asset_pipeline.html">Multi-Media Asset Pipeline</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../scenegraph_for_dummies.html">Scenegraph for Dummies</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../../tutorials/beginner/hellovector.html">Hello Vector</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../terminology.html">Terminology</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/how_to_use_materials.html">How to Use Materials</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../intermediate/transparency_sorting.html">Transparency and Sorting</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../external/blender.html">Importing from Blender</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="../external/3dsmax.html">Importing from 3DS Max</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../logo.html">Logo Usage</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../bsd_license.html">License</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../github_tips.html">Github Tips</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">SDK</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../sdk.html">jMonkeyEngine SDK</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Tutorials</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../tutorials/beginner/beginner.html">Beginner tutorials</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_simpleapplication.html">Hello SimpleApplication</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_node.html">Hello Node</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_asset.html">Hello Asset</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_main_event_loop.html">Hello Update Loop</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_input_system.html">Hello Input System</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_material.html">Hello Material</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_animation.html">Hello Animation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_picking.html">Hello Picking</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_collision.html">Hello Collision</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_terrain.html">Hello Terrain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_audio.html">Hello Audio</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_effects.html">Hello Effects</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../tutorials/beginner/hello_physics.html">Hello Physics</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Docs</span>
    <span class="version">master</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Docs</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../documentation.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Wiki UI</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../wiki-ui/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../documentation.html">Docs</a></li>
    <li><a href="application_states.html">Application States</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/mitm001/jme-wiki/edit/sdk-mod/docs/modules/ROOT/pages/jme3/advanced/application_states.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">Application States</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The <code>com.jme3.app.state.AppState</code> class is a customizable jME3 interface that allows you to control the global game logic, the overall game mechanics. (To control the behaviour of a Spatial, see <a href="custom_controls.html" class="page">Custom Controls</a> instead. Controls and AppStates can be used together.)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview"><a class="anchor" href="#overview"></a>Overview</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="use-case-examples"><a class="anchor" href="#use-case-examples"></a>Use Case Examples</h3>
<div class="paragraph">
<p>There are situations during your game development where you think:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mouse and key inputs are handled differently in-game versus in the main menu. Can I group a set of input handler settings, and activate and deactivate them all in one step?</p>
</li>
<li>
<p>I have the in-game scene, and a character editor, and a Captain&#8217;s Quarters screen. Can I group a set of nodes and behaviours, and swap them in and out in one step?</p>
</li>
<li>
<p>When I pause the game, I want the character&#8217;s &#8220;idle&#8221; animation to continue, but all other loops and game events should stop. How do I define what happens when the game is paused/unpaused?</p>
</li>
<li>
<p>I have a conditional block that takes up a lot of space in my simpleUpdate() loop. Can I wrap up this block of code, and switch it on and off in one step?</p>
</li>
<li>
<p>Can I package everything that belongs in-game, and everything that belongs to the menu screen, and switch between these two &#8220;big&#8221; states in one step?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can! This is what AppStates are there for. An AppState class is subset of (or an extension to) your application. Every AppState class has access to all fields in your main application (AssetManager, ViewPort, StateManager, InputManager, RootNode, GuiNode, etc) and hooks into the main update loop. An AppState can contain:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a subset of class fields, functions, methods (game state data and accessors),</p>
</li>
<li>
<p>a subset of <abbr title="Graphical User Interface">GUI</abbr> elements and their listeners,</p>
</li>
<li>
<p>a subset of input handlers and mappings,</p>
</li>
<li>
<p>a subset of nodes that you load and attach to the rootNode,</p>
</li>
<li>
<p>a subset of conditional actions that you branch to in the simpleUpdate() loop,</p>
</li>
<li>
<p>a subset of other AppStates and Controls</p>
</li>
<li>
<p>… or combinations thereof.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="supported-features"><a class="anchor" href="#supported-features"></a>Supported Features</h3>
<div class="paragraph">
<p>Each AppState lets you define what happens to it in the following situations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>The AppState is initialized:</strong> You load and initialize game data, InputHandlers, AppStates and Controls and attach nodes.<br>
The AppState executes its own simpleInitApp() method when it is attached, so to speak.</p>
</li>
<li>
<p><strong>The AppState has been enabled (unpaused):</strong> This toggles a boolean isEnabled() to true. Here you attach nodes and listeners that should become active while it&#8217;s running.</p>
</li>
<li>
<p><strong>While the AppState is running/paused:</strong> You can poll isEnabled() to define paused and unpaused game behaviour in the update() loop. In update(), you poll and modify the game state, modify the scene graph, and trigger events. Test if <code>!isEnabled()</code>, and write code that skips the running sections of this AppState&#8217;s <code>update()</code> loop.<br>
Each AppState has its own update loop, which hooks into the main simpleUpdate() loop (callback).</p>
</li>
<li>
<p><strong>The AppState has been disabled (paused):</strong> This toggles a boolean isEnabled() to false. Here you switch all objects to their specific &#8220;paused&#8221; behaviour.</p>
</li>
<li>
<p><strong>The AppState is cleaned up:</strong> Here you decide what happens when the AppState is detached. Save this AppState&#8217;s game state, unregister Controls and InputHandlers, detach related AppStates, detach nodes from the rootNode, etc.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>AppStates are extremely handy to swap out, or pause/unpause whole sets of other AppStates. For example, an InGameState (loads in-game <abbr title="Graphical User Interface">GUI</abbr>, activates click-to-shoot input mappings, inits game content, starts game loop) versus MainScreenState (stops game loop, saves and detaches game content, switches to menu screen <abbr title="Graphical User Interface">GUI</abbr>, switches to click-to-select input mappings).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="usage"><a class="anchor" href="#usage"></a>Usage</h3>
<div class="paragraph">
<p>To implement game logic:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create one AbstractAppState instance for each set of game mechanics.</p>
</li>
<li>
<p>Implement game behaviour in the AppState&#8217;s update() method.</p>
<div class="ulist">
<ul>
<li>
<p>You can pass custom data as arguments in the constructor.</p>
</li>
<li>
<p>The AppState has access to everything inside the app&#8217;s scope via the Application <code>app</code> object.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Create and attach the AppState to the AppStateManager (<code>stateManager.attach(myAppState);</code>) and initialize it.</p>
</li>
<li>
<p>Enable and disable (unpause and pause) the AppStates that you need during the game.</p>
</li>
<li>
<p>Detach the AppState from the AppStateManager (<code>stateManager.detach(myAppState);</code>) and clean it up.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When you add several AppStates to one Application and activate them, their initialize() methods and update() loops are executed in the order in which the AppStates were added to the AppStateManager.</p>
</div>
</div>
<div class="sect2">
<h3 id="code-samples"><a class="anchor" href="#code-samples"></a>Code Samples</h3>
<div class="paragraph">
<p>JME3 comes with a BulletAppState that implements Physical behaviour (using the jBullet library). You, for example, could write an Artificial Intelligence AppState to control all your enemy units. Existing examples in the code base include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-bullet/src/common/java/com/jme3/bullet/BulletAppState.java">BulletAppState</a> controls physical behaviour in PhysicsControl&#8217;ed Spatials.</p>
</li>
<li>
<p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/app/state/TestAppStates.java">TestAppStates.java</a> an example of a custom AppState</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/app/state/RootNodeState.java">RootNodeState.java</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appstate"><a class="anchor" href="#appstate"></a>AppState</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The AppState interface lets you initialize sets of objects, and hook a set of continuously executing code into the main loop.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">AppState Method</th>
<th class="tableblock halign-left valign-top">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>initialize(asm,app)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>When this AppState is added to the game, the RenderThread initializes the AppState and then calls this method. You can modify the scene graph from here (e.g. attach nodes). To get access to the main app, call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">super.initialize(stateManager, app);
this.app = (SimpleApplication) app;</code></pre>
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>cleanup()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This method is executed after you remove the AppState from the game. Here you implement clean-up code for when this state is detached. You can modify the scene graph from here (e.g. detach nodes).</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>update(float tpf)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Here you implement the behaviour that you want to hook into the simpleUpdate() loop while this state is attached to the game. You can modify the scene graph from here.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>isInitialized()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Your implementations of this interface should return the correct respective boolean value. (See AbstractAppState)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>setEnabled(true)<br>
setEnabled(false)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Temporarily enables or disables an AppState. (See AbstractAppState)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>isEnabled()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Test whether AppState is enabled or disabled. Your implementation should consider the boolean. (See AbstractAppState)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>stateAttached(asm)<br>
stateDetached(asm)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>The AppState knows when it is attached to, or detached from, the AppStateManager, and triggers these two methods. Don&#8217;t modify the scene graph from here! (Typically not used.)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>render(RenderManager rm)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Renders the state, plus your optional customizations. (Typically not used.)</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>postRender()</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Called after all rendering commands are flushed, including your optional customizations. (Typically not used.)</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="abstractappstate"><a class="anchor" href="#abstractappstate"></a>AbstractAppState</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-core/src/main/java/com/jme3/app/state/AbstractAppState.java">AbstractAppState</a> class already implements some common methods (<code>isInitialized(), setEnabled(), isEnabled()</code>) and makes creation of custom AppStates a bit easier. We recommend you extend AbstractAppState and override the remaining AppState methods: <code>initialize(), setEnabled(), cleanup()</code>.</p>
</div>
<div class="paragraph">
<p>Definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyAppState extends AbstractAppState {

    private SimpleApplication app;

    private Node x = new Node("x");  // some custom class fields...
    public Node getX(){ return x; }  // some custom methods...

    @Override
    public void initialize(AppStateManager stateManager, Application app) {
      super.initialize(stateManager, app);
      this.app = (SimpleApplication)app;          // cast to a more specific class

      // init stuff that is independent of whether state is PAUSED or RUNNING
      this.app.getRootNode().attachChild(getX()); // modify scene graph...
      this.app.doSomething();                     // call custom methods...
   }

   @Override
    public void cleanup() {
      super.cleanup();
      // unregister all my listeners, detach all my nodes, etc...
      this.app.getRootNode().detachChild(getX()); // modify scene graph...
      this.app.doSomethingElse();                 // call custom methods...
    }

    @Override
    public void setEnabled(boolean enabled) {
      // Pause and unpause
      super.setEnabled(enabled);
      if(enabled){
        // init stuff that is in use while this state is RUNNING
        this.app.getRootNode().attachChild(getX()); // modify scene graph...
        this.app.doSomethingElse();                 // call custom methods...
      } else {
        // take away everything not needed while this state is PAUSED
        ...
      }
    }

    // Note that update is only called while the state is both attached and enabled.
    @Override
    public void update(float tpf) {
      // do the following while game is RUNNING
      this.app.getRootNode().getChild("blah").scale(tpf); // modify scene graph...
      x.setUserData(...);                                 // call some methods...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="baseappstate"><a class="anchor" href="#baseappstate"></a>BaseAppState</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A new <a href="https://javadoc.jmonkeyengine.org/v3.3.2-stable/com/jme3/app/state/BaseAppState.html">BaseAppState</a> class was introduced as part of the <a href="https://hub.jmonkeyengine.org/t/jmonkeyengine-3-1-alpha-4-released/35478">updates</a> being made to the AppState interface. AbstractAppState is the most minimal of the minimal implementations of the AppState interface. You essentially still need to do everything yourself, including getting the funky enable/disable/initialized/terminate logic right. Now you just extend BaseAppState and you get onEnable() and onDisable() already worked out for you.</p>
</div>
<div class="paragraph">
<p>Definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyBaseAppState extends BaseAppState {
    @Override
    protected void initialize(Application app) {
        //It is technically safe to do all initialization and cleanup in the
        //onEnable()/onDisable() methods. Choosing to use initialize() and
        //cleanup() for this is a matter of performance specifics for the
        //implementor.
        //TODO: initialize your AppState, e.g. attach spatials to rootNode
    }

    @Override
    protected void cleanup(Application app) {
        //TODO: clean up what you initialized in the initialize method,
        //e.g. remove all spatials from rootNode
    }

    //onEnable()/onDisable() can be used for managing things that should
    //only exist while the state is enabled. Prime examples would be scene
    //graph attachment or input listener attachment.
    @Override
    protected void onEnable() {
        //Called when the state is fully enabled, ie: is attached and
        //isEnabled() is true or when the setEnabled() status changes after the
        //state is attached.
    }

    @Override
    protected void onDisable() {
        //Called when the state was previously enabled but is now disabled
        //either because setEnabled(false) was called or the state is being
        //cleaned up.
    }

    @Override
    public void update(float tpf) {
        //TODO: implement behavior during runtime
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notable BaseAppState changes are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You no longer need to call super.initialize(stateManager, app) because it is now called by BaseAppState upon initialization for you.</p>
</li>
<li>
<p>You no longer have to cast SimpleApplication to have access to AssetManager, AppStateManager, and you can even get a State directly. The getters getApplication(), getAssetManager(), getState(type) and their methods are available to you immediately. However, you still have to cast SimpleApplication to get rootNode.</p>
</li>
<li>
<p>You no longer call super during cleanup, its done for you now.</p>
</li>
<li>
<p>It&#8217;s now safe to do all initialization and cleanup in the onEnable()/onDisable() methods.</p>
</li>
<li>
<p>Cleanup and setEnabled now have logging built in.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You use BaseAppState as you would AbstractAppState, other than mentioned above, and which one you use is entirely up to you. However, BaseAppState makes your life easier and is the recommended one to use now.</p>
</div>
<div class="paragraph">
<p>See <a href="https://javadoc.jmonkeyengine.org/v3.3.2-stable/com/jme3/app/state/BaseAppState.html">BaseAppState</a> for more information.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pausing-and-unpausing"><a class="anchor" href="#pausing-and-unpausing"></a>Pausing and Unpausing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You define what an AppState does when Paused or Unpaused, in the <code>setEnabled()</code> and <code>update()</code> methods. Call <code>myState.setEnabled(false)</code> on all states that you want to pause. Call <code>myState.setEnabled(true)</code> on all states that you want to unpause.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appstatemanager"><a class="anchor" href="#appstatemanager"></a>AppStateManager</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The com.jme3.app.state.AppStateManager holds the list of AppStates for an application. AppStateManager ensures that active AppStates can modify the scene graph, and that the update() loops of active AppStates is executed. There is one AppStateManager per application. You typically attach several AppStates to one AppStateManager, but the same state can only be attached once.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">AppStateManager Method</th>
<th class="tableblock halign-left valign-top">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>hasState(myState)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Is AppState object 'myState' attached?</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>getState(MyAppState.class)</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Returns the first attached state that is an instance of a subclass of <code>MyAppState.class</code>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The AppStateManager&#8217;s <code>render(), postRender(), cleanup()</code> methods are internal, ignore them, users never call them directly.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a detached AppState is attached then initialize() will be called on the following render pass.</p>
</li>
<li>
<p>If an attached AppState is detached then cleanup() will be called on the following render pass.</p>
</li>
<li>
<p>If you attach an already-attached AppState then the second attach is a no-op and will return false.</p>
</li>
<li>
<p>If you both attach and detach an AppState within one frame then neither initialize() or cleanup() will be called, although if either is called both will be.</p>
</li>
<li>
<p>If you both detach and then re-attach an AppState within one frame then on the next update pass its cleanup() and initialize() methods will be called in that order.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="best-practices"><a class="anchor" href="#best-practices"></a>Best Practices</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="communication-among-appstates"><a class="anchor" href="#communication-among-appstates"></a>Communication Among AppStates</h3>
<div class="paragraph">
<p>You can only access other AppStates (read from and write to them) from certain places: From a Control&#8217;s update() method, from an AppState&#8217;s update() method, and from the SimpleApplication&#8217;s simpleUpdate() loop. Don&#8217;t mess with the AppState from other places, because from other methods you have no control over the order of modifications; the game can go out of sync because you can&#8217;t know when (during which half-finished step of another state change) your modification will be performed.</p>
</div>
<div class="paragraph">
<p>You can use custom accessors to get data from AppStates, to set data in AppStates, or to trigger methods in AppStates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">this.app.getStateManager().getState(MyAppState.class).doSomeCustomStuffInThisState();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="initialize-familiar-class-fields"><a class="anchor" href="#initialize-familiar-class-fields"></a>Initialize Familiar Class Fields</h3>
<div class="paragraph">
<p>To access class fields of the SimpleApplication the way you are used to, initialize them to local variables, as shown in the following AppState template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">private SimpleApplication app;
private Node              rootNode;
private AssetManager      assetManager;
private AppStateManager   stateManager;
private InputManager      inputManager;
private ViewPort          viewPort;
private BulletAppState    physics;

public class MyAppState extends AbstractAppState {
  @Override
  public void initialize(AppStateManager stateManager, Application app) {
    super.initialize(stateManager, app);
    this.app = (SimpleApplication) app; // can cast Application to something more specific
    this.rootNode     = this.app.getRootNode();
    this.assetManager = this.app.getAssetManager();
    this.stateManager = this.app.getStateManager();
    this.inputManager = this.app.getInputManager();
    this.viewPort     = this.app.getViewPort();
    this.physics      = this.stateManager.getState(BulletAppState.class);
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>Copyright 2020 jMonkeyEngine Wiki Contributors. Licensed BSD-3.</p>
</footer>
<script src="../../../_/js/vendor/docsearch.min.js"></script>
<!-- fetched from https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js -->
<script>
var search = docsearch({
  apiKey: '',
  indexName: '',
  inputSelector: '#search-input',
  autocompleteOptions: { hint: false, keyboardShortcuts: ['s'] },
  algoliaOptions: { hitsPerPage: 10 }
}).autocomplete
search.on('autocomplete:closed', function () { search.autocomplete.setVal() })
function focusSearchInput () { document.querySelector('#search-input').focus() }
if (document.querySelector('.home-link.is-current')) window.addEventListener('load', focusSearchInput)
</script>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
